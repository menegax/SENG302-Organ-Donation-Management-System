package utility;

import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuBar;
import javafx.scene.control.MenuItem;
import javafx.scene.control.TextField;
import javafx.scene.input.RotateEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.input.TouchEvent;
import javafx.scene.input.ZoomEvent;
import javafx.scene.layout.*;
import javafx.scene.text.Font;
import javafx.stage.Screen;
import javafx.stage.Window;

import java.awt.*;
import java.awt.geom.Rectangle2D;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Wrapper class for a Pane object to enable base touch functionality, including zooming, rotating and scrolling
 */
public class TouchPaneController {

    /**
     * Pane to perform touch operations on
     */
    private final Pane pane;

    private javafx.geometry.Rectangle2D bounds = Screen.getPrimary().getVisualBounds();

    /**
     * Creates a new TouchPaneController
     * @param pane base pane
     */
    public TouchPaneController(Pane pane) {
        this.pane = pane;
//        this.pane.getProperties().put("focusArea", "true");
    }

    /**
     * Zooms in and out of the pane by the zoom event generated by the user
     * @param zoomEvent zoom event
     */
    public void zoomPane(ZoomEvent zoomEvent) {
        pane.toFront();
        pane.setScaleX(pane.getScaleX() * zoomEvent.getZoomFactor());
        pane.setScaleY(pane.getScaleY() * zoomEvent.getZoomFactor());
    }

    /**
     * Rotates the pane using the rotate event generated by the user
     * @param rotateEvent rotate event
     */
    public void rotatePane(RotateEvent rotateEvent) {
        pane.toFront();
        pane.setRotate(pane.getRotate() + rotateEvent.getAngle() * 0.8);
    }

    /**
     * Scrolls in four directions along pane by a scroll event generated by the user.
     * If the pane is out of bounds of the stage, the pane is translated to the opposite side of the window
     * @param scrollEvent scroll event
     */
    public void scrollPane(ScrollEvent scrollEvent) {
        pane.toFront();
        if(!outOfBoundsX()) {
            pane.setTranslateX(pane.getTranslateX() + scrollEvent.getDeltaX());
        } else {
            if(pane.getTranslateX() < 0) {
                pane.setTranslateX(bounds.getMaxX() - pane.getWidth() / 2 + scrollEvent.getDeltaX());
            } else {
                pane.setTranslateX(-1 * pane.getWidth() / 2 + scrollEvent.getDeltaX());
            }
        }

        if(!outOfBoundsY()) {
            pane.setTranslateY(pane.getTranslateY() + scrollEvent.getDeltaY());
        } else {
            if(pane.getTranslateY() < 0) {
                pane.setTranslateY(bounds.getMaxY() - pane.getHeight() / 2 + scrollEvent.getDeltaY());
            } else {
                pane.setTranslateY(-1 * pane.getHeight() / 2 + 200 + scrollEvent.getDeltaY());
            }
        }
    }


    /**
     * Returns true if the pane is out of bounds of the stage.
     * Buffers of half the pane width and the pane width for positive and negative translations respectively
     * are given to minimise risk of pane stopping off screen.
     * @return boolean out of bounds
     */
    private boolean outOfBoundsX() {
        return pane.getTranslateX() > bounds.getMaxX() - pane.getWidth() / 2 || pane.getTranslateX() <= bounds.getMaxX() * -1 + pane.getWidth() / 2;
    }

    /**
     * Returns true if the pane is out of bounds of the stage.
     * Buffers of half the pane height and the pane height for positive and negative translations respectively
     * are given to minimise risk of pane stopping off screen.
     * @return boolean out of bounds
     */
    private boolean outOfBoundsY() {
        return pane.getTranslateY() > bounds.getMaxY() - pane.getHeight() / 2 || pane.getTranslateY() <= bounds.getMaxY() * -1 + pane.getHeight() / 2;
    }

}
