package utility;

import TUIO.TuioCursor;
import TUIO.TuioTime;
import javafx.event.Event;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuBar;
import javafx.scene.control.MenuItem;
import javafx.scene.control.TextField;
import javafx.scene.input.*;
import javafx.scene.layout.*;
import javafx.scene.text.Font;
import javafx.stage.Screen;
import javafx.stage.Window;
import org.tuiofx.Configuration;
import org.tuiofx.examples.demo.touchpointdata.TouchPointDataController;
import org.tuiofx.internal.base.GestureHandler;
import org.tuiofx.internal.gesture.TuioJFXEvent;
import org.tuiofx.internal.gesture.TuioTouchPoint;

import java.awt.*;
import java.awt.geom.Rectangle2D;
import java.util.*;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Wrapper class for a Pane object to enable base touch functionality, including zooming, rotating and scrolling
 */
public class TouchPaneController {

    /**
     * Pane to perform touch operations on
     */
    private final Pane pane;
    private Map<Integer, TuioTouchPoint> touchMap = new HashMap<>();
    private GestureHandler gestureHandler;


    private javafx.geometry.Rectangle2D bounds = Screen.getPrimary().getVisualBounds();

    /**
     * Creates a new TouchPaneController
     * @param pane base pane
     */
    public TouchPaneController(Pane pane) {
        this.pane = pane;
        gestureHandler = new GestureHandler(Configuration.debug());
//        this.pane.getProperties().put("focusArea", "true");
    }

    public void convertEvent(TouchEvent event) {
        System.out.println(event);
        TouchPoint point = event.getTouchPoint();
        if(event.getEventType().getName().equals("TOUCH_PRESSED")){
            addTouchPoint(point, event);
        } else if (event.getEventType().getName().equals("TOUCH_MOVED")) {
            updateTouchPoint(point, event);
        } else if (event.getEventType().getName().equals("TOUCH_RELEASED")) {
            releaseTouchPoint(point);
        }
        event.consume();
    }

    private void addTouchPoint(TouchPoint point, TouchEvent event) {
        TuioTouchPoint touchPoint = convertToTUIO(point, TuioTouchPoint.State.STARTED);
        touchPoint.setTargetNode(event.getTarget());
        touchPoint.setCurrentTargetNode(event.getTarget());
        gestureHandler.touchesBegan(touchPoint);
        touchMap.put(point.getId(), touchPoint);
    }

    private void updateTouchPoint(TouchPoint point, TouchEvent event) {
        int id = point.getId();
        TuioTouchPoint touchPoint = touchMap.get(id);
        if(touchPoint.getState().equals(TuioTouchPoint.State.STARTED)) {
            TuioTouchPoint newTouchPoint = convertToTUIO(point, TuioTouchPoint.State.MOVED);
            touchMap.replace(point.getId(), touchPoint, newTouchPoint);
        } else {
            touchPoint.update(event.getTarget(), point.getSceneX(), point.getSceneY());
        }
        touchPoint = touchMap.get(id);
        gestureHandler.touchesMove(touchPoint);
    }

    private void releaseTouchPoint(TouchPoint point) {
        TuioTouchPoint touchPoint = convertToTUIO(point, TuioTouchPoint.State.ENDED);
        gestureHandler.touchesEnd(touchPoint);
        touchMap.remove(point.getId());
    }

    private TuioTouchPoint convertToTUIO(TouchPoint point, TuioTouchPoint.State state) {
        TuioCursor cursor = new TuioCursor(new TuioTime(), 0, 0, 0, 0);
        return new TuioTouchPoint(cursor, point.getScreenX(), point.getScreenY(), point.getSceneX(), point.getSceneY(), state);
    }

    /**
     * Zooms in and out of the pane by the zoom event generated by the user
     * @param zoomEvent zoom event
     */
    public void zoomPane(ZoomEvent zoomEvent) {

    }

    /**
     * Rotates the pane using the rotate event generated by the user
     * @param rotateEvent rotate event
     */
    public void rotatePane(RotateEvent rotateEvent) {

    }

    /**
     * Scrolls in four directions along pane by a scroll event generated by the user.
     * If the pane is out of bounds of the stage, the pane is translated to the opposite side of the window
     * @param scrollEvent scroll event
     */
    public void scrollPane(ScrollEvent scrollEvent) {

    }


    /**
     * Returns true if the pane is out of bounds of the stage.
     * Buffers of half the pane width and the pane width for positive and negative translations respectively
     * are given to minimise risk of pane stopping off screen.
     * @return boolean out of bounds
     */
    private boolean outOfBoundsX() {
        return pane.getTranslateX() > bounds.getMaxX() - pane.getWidth() / 2 || pane.getTranslateX() <= bounds.getMaxX() * -1 + pane.getWidth() / 2;
    }

    /**
     * Returns true if the pane is out of bounds of the stage.
     * Buffers of half the pane height and the pane height for positive and negative translations respectively
     * are given to minimise risk of pane stopping off screen.
     * @return boolean out of bounds
     */
    private boolean outOfBoundsY() {
        return pane.getTranslateY() > bounds.getMaxY() - pane.getHeight() / 2 || pane.getTranslateY() <= bounds.getMaxY() * -1 + pane.getHeight() / 2;
    }

}
